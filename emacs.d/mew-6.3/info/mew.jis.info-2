Info file: mew.jis.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `mew.texi'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

INFO-DIR-SECTION Message User Agent
START-INFO-DIR-ENTRY
* Mew-J: (mew.jis.info).     Messaging in the Emacs World.
END-INFO-DIR-ENTRY






File: mew.jis.info, Node: longline, Next: reply, Prev: charset-guess, Up: Composing

長い行の取り扱い
================

長い間、メッセージに書く文章は、自分自身で各行を(英文字で)70文字程度に
折り返すべきだとされてきました。RFC 3676 で Text/Plain が拡張され、
format パラメータに flowed という値が定義されました。

このおかげで、送り側で長い行を目印を付けて折り返し、受け取り側で長い行
に戻せるようになりました。ユーザの目から見れば、メッセージに長い行を気
軽に書いてもよくなったということです。

Mew で、長い行を flowed で折り返すには 2 つの方法があります。

1) 明示的に折り返すには、`C-cC-f'を実行します。

このコマンドは、草稿に長い行があるかを調べます。
`mew-flowed-fold-threshold' を越える行が見つかったら、flowed で折り返し
を実行します。この変数の値は 78 です。

折り返した行が、何文字以内になるかを制御する変数が
`mew-flowed-fold-length'です。初期値は 70 です。

折り返す方法は、文字コードによって変わります。分かち書きをする文字コー
ドでは、既存の空白文字の後に改行文字を入れて折り返します(delsp=no)。分
かち書きをしない文字コードでは、適切な場所に空白文字と改行文字の両方を
挿入して折り返します(delsp=yes)。

もう一度 `C-cC-f' を実行すると、折り返された行が元に戻ります。

2) `mew-use-format-flowed' が `t' の場合は、`C-cC-c'や`C-cC-m'でメッセー
ジを作成するときに、この機能が働きます。この変数の初期値は `nil' です。

なお、メッセージを表示する際は、`mew-use-format-flowed' の値に関係なく
flowed で折り返された行は、元に戻されます。長い行が見にくい場合は、
Summary モードで `_' を利用しましょう。

`mew-flowed-auto-wrap' が `t' の場合、メッセージを表示すると、元に戻さ
れた行に一回 `_' が実行され、折り返された状態で表示されます。
`mew-flowed-auto-wrap' のデフォルトの値は `t' です。



File: mew.jis.info, Node: reply, Next: forward, Prev: longline, Up: Composing

メッセージへの返答と宛先の決定
==============================

新規にメッセージを書く場合は、To:、Cc:、および Newsgroups: を自分で書く
ことになります。一方 Summary モードで `a' や `A' を使って、あるメッセー
ジに返答しようとすると、To:、Cc:、Newsgroups: は自動的に用意されます。

Summary モードで `a' や `A' を使うと、新しい草稿が Draft mode に用意さ
れます。To:、Cc:、Newsgroups: の値は、以下の三つの alist に従って用意さ
れます。

  1. もし `C-u' 付きで呼び出された場合、送信者/投稿者のみに返答する。こ
     の場合、`mew-reply-sender-alist' が利用される。
  2. もし対象が自分自身で送ったメッセージなら、そのヘッダを加工せずに返
     答したいのであろう。この場合、`mew-reply-fromme-alist' が利用され
     る。
  3. そうでなければ、すべての人に返答する。この場合、
     `mew-reply-all-alist' が利用される。

`mew-reply-sender-alist' の初期値は以下の通りです。

     '(("Reply-To:"
        ("To:" "Reply-To:" "From:"))
       (t
        ("To:" "From:")))

これは、次のように解釈します。

  1. Reply-To: が存在すれば、Reply-To: と From: の値を新しい To: へコピー
     する。
  2. そうでなければ、From: の値を新しい To: へコピーする。

もし、Reply-To: で指定されたアドレスのみに返答したい場合は、
`mew-reply-sender-alist' を以下のように設定するとよいでしょう。

     (setq mew-reply-sender-alist
           '(("Reply-To:"
              ("To:" "Reply-To:"))
             (t
              ("To:" "From:"))))

`mew-reply-fromme-alist' の初期値は以下の通りです。

     '((t
        ("To:" "To:")
        ("Cc:" "Cc:")
        ("Newsgroups:" "Newsgroups:"))))

これは、次のように解釈します。

     To: の値を新しい To: へ、Cc: の値を新しい Cc: へ、Newsgroups: の値
     を新しい Newsgroups: へコピーする。

`mew-reply-all-alist' の初期値は以下の通りです。

     '((("Followup-To:" "poster")
        ("To:" "From:"))
       ("Followup-To:"
        ("Newsgroups:" "Followup-To:" "Newsgroups:"))
       ("Newsgroups:"
        ("Newsgroups:" "Newsgroups:"))
       ("Reply-To:"
        ("To:" "Reply-To:" "From:")
        ("Cc:" "To:" "Cc:" "Apparently-To:"))
       (t
        ("To:" "From:")
        ("Cc:" "To:" "Cc:" "Apparently-To:")))

これは、次のように解釈します。

  1. Follwup-To: の値が "poster" であれば、From: の値を新しい To: へコ
     ピーする。
  2. Follwup-To: が存在すれば、Follwup-To: と Newsgroups: の値を新しい
     Newsgroups: へコピーする。
  3. Newsgroups: が存在すれば、Newsgroups: の値を新しい Newsgroups: へ
     コピーする。
  4. Reply-To: が存在すれば、Reply-To: と From: の値を新しい To: へコピー
     する。また、To:、Cc:、Apparently-To: の値を新しい Cc: へコピーする。
  5. そうでなければ、From: の値を新しい To: へコピーする。また、To:、
     Cc:、Apparently-To: の値を新しい Cc: へコピーする。

`mew-reply-all-alist' を以下のように設定したいと思う人もいるかもしれま
せん。

     (setq mew-reply-all-alist
           '((("Followup-To:" "poster")
              ("To:" "From:"))
             ("Followup-To:"
              ("Newsgroups:" "Followup-To:"))
             ("Newsgroups:"
              ("Newsgroups:" "Newsgroups:"))
             ("Reply-To:"
              ("To:" "Reply-To:"))
             (t
              ("To:" "From:")
              ("Cc:" "To:" "Cc:" "Apparently-To:"))))

あるアドレスが複数ある場合は、自動的に 1 つになります。また、匿名の宛先
を表す ":;" で終るアドレスも、自動的に消去されます。

自分のアドレスは自動的に消去されます。自分のアドレスは、
`mew-config-alist' などから `mew-mail-address-list' に自動設定されます。
この値が気に入らないなら、以下のように明示的に設定することも可能です。

     (setq mew-mail-address-list
            '("^pooh@[a-z]*.example.org$"
              "^pooh@example.net$"
              "^winnie@example.jp$"))



File: mew.jis.info, Node: forward, Next: resend, Prev: reply, Up: Composing

メッセージの転送
================

メッセージを転送するには、Summary モードで `f' や `F' を利用します。す
ると、Draft モードに移行し、あらかじめメッセージが添付領域に添付された
草稿が準備されます。

また Draft モードで添付領域を用意し、メッセージをコピー(`c')したりメッ
セージにリンク(`l')を張ったりしても、メッセージを転送できます。ファイル
名が数字([0-9]+)の場合は、自動的にメッセージだと判断されます。また、添
付領域で `y' を使うと、Message モードに表示しているメッセージにリンクを
張るので便利です。

通常は添付したメッセージの全体が転送されます。もし、ヘッダの一部を削りた
い場合は、`mew-field-delete-for-forwarding' を定義して下さい。以下
に "Received:" と "Return-Path:" を転送時に削るための設定例を示します。

     (setq mew-field-delete-for-forwarding '("Received:" "Return-Path:"))



File: mew.jis.info, Node: resend, Next: shortcut, Prev: forward, Up: Composing

メッセージの再送
================

メッセージのヘッダの一部のみを変更して、送信したい場合があります。

たとえば、同じ内容のメッセージを、複数の宛先に独立して送りたい場合です。
pooh 宛のメッセージを作成して、+queue に入れ、すぐさまそのメッセージを
コピーし、宛先だけを piglet に変更したい場合を想像して下さい。これを、
メッセージの再利用による送信と呼びましょう。

また、メッセージに Resent-To: というフィールドを付けて再送したいことも
あります。これは、転送の一種です。こちらはヘッダだけ書き直すので、ヘッ
ダ変換といいます。前節で説明した転送は、メッセージを新規のメッセージに
包み込んで転送するため、カプセル化と呼ばれています。

ヘッダの一部だけを編集し、メッセージを送信したり、キューに入れたりする
モードとして、Header モードが用意されています。本文が編集できない
Draft モードだと思えばいいでしょう。

Header モードに入るために、Summary モードには以下のコマンドが用意されて
います。

`W'
     メッセージの再利用による送信。対象となるメッセージの To:、Cc:、
     From: などを書き換えるために、Header モードに移行する。典型的には、
     +queue または +postq に入っているメッセージに対して利用する。
`r'
     メッセージの再送。対象となるメッセージのヘッダに、Resent-To:、
     Resent-Cc:、Resent-From: などを追加するために、Header モードに移行
     する。再送によるメッセージの転送は、受信者を混乱させることがあるの
     で、よく考えてから利用すること。

Header モードでは、Draft モードのように、補完や循環的な補完が利用できま
す。ヘッダの入力が終わったら、以下のどちらかのコマンドを用いて、メッセー
ジを送信して下さい。本文が表示されていないので不安かもしれませんが、ちゃ
んと対象となっているメッセージの本文とヘッダの一部が再利用されます。

`C-cC-m'
     メッセージを作成し +queue または +postq に入れ、送信待ち状態にする。
`C-cC-c'
     メッセージを作成し送信する。"Really send this message? (y or n) "
     と訊かれる。`y' を押せば送信される。



File: mew.jis.info, Node: shortcut, Next: mark-b-comp, Prev: resend, Up: Composing

電子署名/暗号メールを作成する
=============================

ここでは、テキストである本文を PGP や S/MIME で署名したり暗号化したりす
る方法について説明します。紹介するコマンドは以下の通りです。

`C-cC-s'
     草稿全体を署名する。パスフレーズを入力すること。
`C-cC-e'
     草稿全体を暗号化する。
`C-cC-b'
     草稿全体を署名後暗号化する。パスフレーズを入力すること。
`C-cC-r'
     草稿全体を暗号化後署名する。パスフレーズを入力すること。

メッセージを暗号化するには受信者の公開鍵を使用します。逆に署名するには
自分の秘密鍵を使います。よって、署名するためにはパスフレーズを入力する
必要があります。ただし、パスフレーズの保存機能やマスターパスワードを使っ
ており、パスフレーズが保存されている場合は、パスフレーズを入力する必要
はありません(*Note password::)。

これらのコマンドは、通常 PGP/MIME を作成します。S/MIME を作成したい場合
は、以下のように設定して下さい。

     (setq mew-draft-privacy-method 'smime)

この変数の値は、Draft モードの `C-cC-pC-m' でも変更できます。

上記4つのコマンドは、次節で説明するマークを使った作成方法の省略方法に当
たります。

メッセージに署名を施すには、`C-cC-s' と入力します。署名の際には、自分の
秘密鍵を復号化する必要がありますので、パスフレーズがキャッシュされてい
なければ、入力を促されます。署名が施されたメッセージは、+queue または
+postq に格納されます。

自分の秘密鍵は、From: にあるアドレスを元に特定されます。From: がない場
合は、デフォルトの秘密鍵が選択されます。From: にあるアドレスとは違うア
ドレスで秘密鍵を指定したい場合は、`C-uC-cC-s' と入力して下さい。

メッセージを暗号化するには、`C-cC-e' とタイプして下さい。To: や Cc: か
らアドレスを切り出して、その受信者が復号化できるよう暗号化します。暗号
化するだけのなので、パスフレーズを訊かれることはありません。作成された
メッセージは、+queue に格納されます。

このメッセージは、受信者の公開鍵に加えて、自分の公開鍵でも暗号化されて
います。ですから、作成したメッセージを復号化できます。たとえば、`g' で
+queue に移動し、念のため復号化して確認することが可能です。

署名後暗号化するには、`C-cC-b' と入力します。暗号化後署名するには、
`C-cC-r' とタイプします。どちらの場合も作成されたメッセージは、+queue
に蓄えられます。

署名を施したり、暗号化したりしてメッセージを送ろうと思っていても、うっ
かり忘れることがあります。これを防ぐために、メッセージを作成するコマン
ド `C-cC-m' や `C-cC-c' を実行すると、自動的に署名や暗号化を施す機能が
あります。

作成するすべてのメッセージのプライバシを保護したいなら、
`mew-protect-privacy-always' を `t' にして、
`mew-protect-privacy-always-type' に利用したいサービスを設定します。

暗号化されたメッセージに対する返答メッセージのプライバシを保護したいな
ら、`mew-protect-privacy-encrypted' を `t' にして、
`mew-protect-privacy-encrypted-type' に利用したいサービスを設定します。
この設定は、暗号化されたメッセージへの返答する場合、上記のすべてのメー
ルに対する設定よりも優先されます。

以下に利用できるサービスを示します。かっこ内はそれぞれのサービスを表す
シンボルです。`C-cC-m' や `C-cC-c' と入力する際に利用されるサービスは、
モードラインに表示されます。

pgp-signature (PS)
     PGP で署名
pgp-encryption (PE)
     PGP で暗号化
pgp-signature-encryption (PSPE)
     PGP で署名後暗号化
pgp-encryption-signature (PEPS)
     PGP で暗号化後署名
smime-signature (SS)
     S/MIME で署名
smime-encryption (SE)
     S/MIME で暗号化
smime-signature-encryption (SSSE)
     S/MIME で署名後暗号化
smime-encryption-signature (SESS)
     S/MIME で暗号化後署名

以下の例は、すべてのメッセージに対し署名する設定です。

     (setq mew-protect-privacy-always t)
     (setq mew-protect-privacy-always-type 'pgp-signature)

以下の例は、暗号化されたメッセージへの返答メッセージに対し、PGP で暗号
化する設定です。

     (setq mew-protect-privacy-encrypted t)
     (setq mew-protect-privacy-encrypted-type 'pgp-encryption)

Draft モードでは、`C-cC-pC-a' で `mew-protect-privacy-always'、
`C-cC-pC-e' で `mew-protect-privacy-encrypted' の値を反転できます。

Draft モードにおいて現在書いている草稿に対してのみあらかじめサービスを
指定しておき、送信時にサービスを施すことを忘れないようにできます。現在
の草稿に対し `C-cC-m' や `C-cC-c' で施されるサービスを指定するには、
`C-cC-pC-d' に続いて上記のサービスの 1 つを入力して下さい。現在のサービ
スをキャンセルするには、サービス名の代りに単に `RET' を押して下さい。

`C-cC-c' や `C-cC-m' でメッセージを作成する際、署名や暗号化に
失敗したら、草稿に戻ります。このとき指定していたサービスはキャンセルされ
ます。続けて `C-cC-c' や `C-cC-m' でメッセージを作成すると、普
通のメッセージが作成されるので気をつけて下さい。問題を取り除いた後、同じ
サービスを望むなら、明示的に `C-cC-pC-d' でサービスを指定するか、
`C-cC-s'、`C-cC-e' などを用いて下さい。


`mew-use-old-pgp' を `t' に設定すれば(初期値は `nil')、`C-cC-s' や
`C-cC-e' は PGP/MIME の代りに、古い PGP の書式に従ってメッセージを生成
します。添付領域がある場合は、エラーになります。

上記で説明した `mew-protect-privacy-*' は、PGP/MIME のみに有効であり、
古い PGP には機能しません。`C-cC-m' や `C-cC-c' で常に古い PGP の署名を
施すには、`mew-protect-privacy-with-old-pgp-signature' を `t' にして下
さい。



File: mew.jis.info, Node: mark-b-comp, Next: pgp-key, Prev: shortcut, Up: Composing

マークを使った電子署名/暗号メールの作成
=======================================

PGP/MIME や S/MIME をサポートするために、マークを使った作成方法が提供さ
れています。以前の例を思い出してみましょう。

     ----------------------------- attachments -----------------------------
           Multipart/Mixed                                         1/
          1  Text/Plain(guess)                                       CoverPage*
     B    2  Image/Gif                    MagicPoint のロゴ          mgp.gif
     Q    3  Application/Postscript       資料                       ohp.ps
          4                                                          .
     --------0-1-2-3-4-5-6-7-8-9--------------------------------------------

行頭に `B' や `Q' といったマークがあります。このマークは符号化を意味し
ています。Mew では、新しい概念「符号化」を導入しています。符号化には、
Base64、Quoted-Printable、Gzip64 (Gzip + Base64)、署名、暗号化などがあ
ります。

現在次の 8 つのマークがサポートされています。

`" "'
     符号化しない。ただし、8 ビットのテキストは符号化されるかもしれない。
`B'
     Base64
`Q'
     Quoted-Printable
`G'
     Gzip64(gzip 圧縮し Base64 で符号化する。Mew が実験的に採用している。
     相手が Mew を使っていない場合は、使用すべきではない。)
`PS'
     PGP で電子署名。
`PE'
     PGP で暗号化。
`SS'
     S/MIME で電子署名。
`SE'
     S/MIME で暗号化。

添付領域でのマークに関係する新しいキー割当は以下の通りです。

`B'
     Base64 で符号化するため `B' マークを付ける。
`Q'
     Quoted-Printable で符号化するため `Q' マークを付ける。
`G'
     Gzip64 で符号化するため `G' マークを付ける。ただし、Text/Plain と
     Application/Postscript でしか実行できない。これ以外の型には圧縮は
     無意味である。なぜなら、jpeg などはあらかじめ圧縮されているから。
`S'
     PGP で署名するため `PS' マークを付ける。
`E'
     PGP で暗号化するため `PE' マークを付ける。受信者のアドレスを入力す
     る。
`M-s'
     S/MIME で署名するため `SS' マークを付ける。
`M-e'
     S/MIME で暗号化するため `SE' マークを付ける。受信者のアドレスを入
     力する。
`U'
     符号化を元に戻す。元々のマークに戻る。

次の例を考えてみましょう。パート 2 は PGP で署名され、"kazu" 用に PGP
で暗号化されます。安心して下さい。説明の部分は上書きされていますが、保
存されています。パート 3 は Gzip64 で符号化されます。

     ----------------------------- attachments -----------------------------
           Multipart/Mixed                                         1/
          1  Text/Plain(guess)                                       CoverPage*
     PSPE 2  Image/Gif                    kazu@example.org          mgp.gif
     G    3  Application/Postscript       資料                       ohp.ps
          4                                                          .
     --------0-1-2-3-4-5-6-7-8-9--------------------------------------------

マークを付けた後は、`C-cC-m' や `C-cC-c' を使って、メッセージを作成して
下さい。



File: mew.jis.info, Node: pgp-key, Next: anonymous, Prev: mark-b-comp, Up: Composing

PGP の鍵の配布
==============

PGP の公開鍵を配布するには、Draft モードの添付領域で `p' を押して下さい。
だれの公開鍵を配布するか尋ねられます。自分の公開鍵であれば、単に `RET'
と入力して下さい。他人の公開鍵であれば、補完を利用しながらその人のアド
レスを入力して下さい。PGP の公開鍵は、Application/Pgp-Keys というデータ
型で配送されます。

Summary モード、あるいは、Virtual モードでメッセージを読んでいる際に、
あるパートのデータ型が Application/Pgp-Keys であれば、Mew は PGP の公開
鍵リングにそれを登録しようとします。Mew は、「信用度」と「有効性」を全
く考慮しないことに注意して下さい。これらの値を設定するのは、あなた自身
です。設定は Mew が表示する説明に従って下さい。もし、「信用度」と「有効
性」の意味が分からなければ、PGP を使って自分のプライバシを保護しようと
する前に、PGP が提供する「信用の輪」とは何かを学ぶべきです。



File: mew.jis.info, Node: anonymous, Next: Marks, Prev: pgp-key, Up: Composing

宛先を匿名にしたメッセージの送信
================================

宛先を匿名にして、複数の受信者にメッセージを送信したいことがあります。

たとえば、pooh がパーティーへのお誘いを複数の友達に送ることを考えて下さ
い。パーティーへ参加するという piglet からの返事は、pooh のみに送るべき
です。しかし、To: にたくさんの友達を列挙していると、piglet は誤って多く
の人に返答を送りつけてしまうかもしれません。そもそも、pooh は誰を誘った
のか、当日までふせておきたいこともあるでしょう。

このような要望を実現するために、Mew では匿名の宛先として、":;" を利用し
ます。以下の例を見て下さい。

     To: party:piglet@example.org,roo@example.org;
     From: Pooh <winnie-the-pooh@example.net>

"party" という説明文字列の後に ":" があります。そして、いくつかアドレス
が "," で区切られながら列挙され、";" で終端されています。このような形式
でアドレスを書くと、Mew は ":" と ";" のアドレスにメッセージを届けます
が、ヘッダからは削り取ります。この例では、piglet と roo は以下のような
メッセージを受け取ります。

     To: party:;
     From: Pooh <winnie-the-pooh@example.net>

受信者はこのヘッダから、送信者は pooh であることは分かりますが、自分以
外の誰に送られたのかは、想像するほかありません。また、"party:;" という
文字列は、アドレスではありませんから、ここに返答することも不可能です。

なお、To: や Cc: にたくさんのアドレスを列挙することは、本質的によいこと
ではありません。特定の人にメッセージを何度も送信する機会があるなら、通
常メーリングリストを作成します。




File: mew.jis.info, Node: Marks, Next: unread mark, Prev: anonymous, Up: Top

愉快なマークたち
****************

ここでは、Summary モードでユーザが付けたり消したりできるマークについて
説明します。このマークは以下のように、行頭に付きます。(Mew が付けるマー
クは日付の左に付くことに注意。)

     D 03/12 Hidenori Ohta  今週末                    |日曜にストーンマジック
     oM03/14 ももちゃん     能登の写真                |この前撮った写真を添付
     * 03/15 Neat Sumikawa  Re: ワイン                |じゃぁ、水曜日に例の店

現在利用できるマークは以下の 6 つです。

`U'
     未読マーク。
`D'
     消去のマーク。
`X'
     消去のマーク。
`o'
     整頓、つまり、フォルダを移動させるマーク。
`*'
     処理の対象とするマーク。
`$'
     マークを一時的に待避するためのマーク。

マークを付けるだけでは、メッセージがなくなったりすることはありません。
`o'、`D'、`X' といったマークを実際に処理するコマンドは、`x' です。マー
クを付けるのは気軽にできますが、`x' を押すときは慎重にお願いします。

以下それぞれについて説明します。また、Mew が表示するマークについてもま
とめます。

* Menu:

* unread mark::                 未読 `U'
* delete mark::                 消去 `D'、`X'
* refile mark::                 整頓 `o'
* target mark::                 対象 `*'
* escape mark::                 待避 `$'
* unmark::                      マークの消去
* mark change::                 マークの変換
* sync::                        IMAP サーバとのマークの整合性
* off-line::                    IMAP のためのマークのオフライン処理
* mew-mark::                    Mew が表示するマーク



File: mew.jis.info, Node: unread mark, Next: delete mark, Prev: Marks, Up: Marks

未読 `U'
========

以下のように設定すると、メッセージを一覧表示する際に、未読マーク
`U' がメッセージに付きます。

     (setq mew-use-unread-mark t)

`SPC'、`n'、および `p' などでメッセージを読むと
`U' マークは消えます。

この三つのコマンドは、通常 `*' マーク、`U' マーク、およびマー
クの付いていないメッセージを読み進みます。`zSPC' を押すと、これら
は `*' マークと `U' マークの付いたメッセージのみを読み進めま
す。これは、未読のメッセージを読み進める場合に便利です。もう一度
`zSPC' を実行すると、対象とするメッセージが元に戻ります。

前のメッセージにマークを付けて、現在のメッセージに移動して来ると、`U'
マークは消えます。`SPC'、`n'、および `p' で移動して来た場合は、このメッ
セージを読むことを意図しているはずですが、マークを付けることで移動した
場合はメッセージを読むことを意図していないかもしれません。その場合、
`U' マークが消えると少し不便です。マークを付けることで移動した際に、
`U' マークを消したくないのであれば、以下のように設定するとよいでしょう。

     (setq mew-delete-unread-mark-by-mark nil)

以下に `U' マークに関するコマンドをまとめます。

`zSPC'
     `SPC'、`n'、および `p' が読み進める対象とするメッセージを反転させ
     る。反転とは、「`U' マーク、`*' マーク、およびマークなし」と「`U'
     マークおよび `*' マーク」に対し、一方を他方へ変えること。
`M-u'
     `U' マークを付ける。




File: mew.jis.info, Node: delete mark, Next: refile mark, Prev: unread mark, Up: Marks

消去 `D'、`X'
=============

メッセージを消去するには、まず Summary モードで `d' を押して、
`D' マークを付けます。マークを付けただけでは何も起こらないので、間
違って `d' を押しても大丈夫です。デフォルトでは、`x' を押すと
`D' マークの付いたメッセージがゴミ箱に移動します。

ローカル・フォルダのためのゴミ箱は +trash です。IMAP のためのゴミ箱は、
%trash です。

ゴミ箱の中のメッセージを実際に消去するには、以下の 2 つの方法があります。

  1. Summary モードで `D' を実行する。
  2. ゴミ箱で `D' マークを付けて、`x' を押す。

もう少し正確に言うと、ローカル・フォルダでは以下のルールが適用されます。
(`mew-trash-folder' の初期値は +trash。
`mew-trash-folder-list' の初期値は `nil'。)

   - `mew-trash-folder' が `nil' なら、`D' マークの付いたメッセージは消
     去される。
   - `mew-trash-folder-list' が定義されていたら、それらのフォルダ
     で `D' マークを付けたメッセージは消去される。それ以外のフォルダからは
     `mew-trash-folder' へ。
   - `mew-trash-folder-list' が `nil' なら、 `mew-trash-folder' で `D'
     マークを付けたメッセージは消去される。それ以外のフォルダからは
     `mew-trash-folder' へ。(これが初期値。)

IMAP に対しては、`mew-imap-trash-folder' と
`mew-imap-trash-folder-list' に従って、同じ規則が適用されます。

すべての `*' マークを `D' マークに変換できれば、一度にたくさんの `D' マー
クを付けられて便利です。これには、`md' を利用して下さい。

また、`Md' を使うと、現在のフォルダ内で同じ Message-Id: を持つメッセー
ジがある場合、1 つを残して他のメッセージに `D' が付きます。

`D' マークに似たものに `X' マークがあります。このマークの付けられたメッ
セージは、`x' を押した際に必ず消去されます。`X' マークは、`M-d' で付け
ることができます。

`mxM-d' で、`X' マークが付いたメッセージだけを処理できます。
すべての `*' マークを `X' マークに変換するコマンドは、
`mM-d' です。


以下に、`D' マークと `X' マークに関するコマンドをまとめます。

`d'
     `D' マークを付ける。
`M-d'
     `X' マークを付ける。
`md'
     `*' マークを `D' マークへ変換する。
`mM-d'
     `*' マークを `X' マークへ変換する。
`x'
     マークの付いたメッセージを処理する。
`mxd'
     `D' マークの付いたメッセージのみを処理する。
`mxM-d'
     `X' マークの付いたメッセージのみを消去する。
`D'
     ゴミ箱の中のメッセージを全部消去する。
`C-uD'
     指定されたフォルダのメッセージを全部消去する。



File: mew.jis.info, Node: refile mark, Next: target mark, Prev: delete mark, Up: Marks

整頓 `o'
========

メッセージを整頓するには `o' を押して、移動先のフォルダを入力し、
`o' マークを付けます。移動先のフォルダは、賢く推測してくれるので、
ほどんどの場合はフォルダ名を入力する代わりに `RET' を押すだけです。
"," で区切って複数のフォルダを入力することもできます。もちろん、
`TAB' で補完できます。詳しくは *Note Refile:: を参照して下さい。

`o' マークの付いたメッセージの上で `o' を押すと、移動先を追加したり変更
したりできます。また、実際の移動は `x' と入力されたときに実行されます。

複数のフォルダを指定し、移動させたときのことを考えましょう。ハードリン
クの機能を持つファイルシステムを使っている場合、そのメッセージは最初の
フォルダに移動され、その他のフォルダからはハードリンクが張られます。そ
うでないファイルシステムの場合は、最初のフォルダに移動後、その他のフォ
ルダへ複製されます。

指定したフォルダが 1 つで、しかもそれが現在のフォルダである場合、整頓し
てもなにも起こりません。指定したフォルダが複数で、現在のフォルダが含ま
れる場合、現在のフォルダ内での番号を保ったまま、その他のフォルダからハー
ドリンクが張られるか、その他のフォルダへ複製されます。

`o' に似ていますが、かならず現在のフォルダも候補として提示する
`c' というコマンドも用意されています。

以下に、`o' マークに関するコマンドをまとめます。

`o'
     `o' マークを付ける。
`c'
     `o' マークを付ける。推測したフォルダに加えて、現在のフォルダも候補
     として提示する。
`x'
     `o' マークの付いたメッセージを移動させる。
`mxo'
     `o' マークの付いたメッセージのみを移動させる。他のマークは処理しない。
`C-umxo'
     `o' マークの付いたメッセージの中で、現在のメッセージと同じ移動先を
     持つもののみを移動させる。



File: mew.jis.info, Node: target mark, Next: escape mark, Prev: refile mark, Up: Marks

対象 `*'
========

後から読み返したいメッセージには、`*' で `*' マークを付けて下さい。また、
選択コマンド `?' を使うと、入力した条件にマッチするメッセージに `*' マー
クが付きます(詳しくは、*Note search:: を参照して下さい)。`N' や `P' で
`*' マークの付いたメッセージに移動し表示できます。

以下に、`*' に関連するコマンドを示します。

`*'
     `*' マークを付ける。
`N'
     下方向の `*' マークの付いたメッセージへ移動し表示。
`P'
     上方向の `*' マークの付いたメッセージへ移動し表示。
`ma'
     マークの付いていないメッセージすべてに `*' マークを付ける。
`mr'
     入力した正規表現にマッチしたメッセージに `*' マークを付ける。

`*' マークは、複数のメッセージを処理するためにも利用します。以下に複数
のメッセージを処理するコマンドを示します。

`F'
     `*' マークの付いたメッセージを MIME 形式で転送するための草稿を準備。
`J'
     大きなメッセージは Message/Partial として複数に分割されている場合
     がある。これらのメッセージには、Mew によって `P' マークが付けられ
     ている。ここで、ユーザがそれらのメッセージに `*' マークを付け、こ
     のコマンドを実行すれば、元のメッセージが復元される。
`mI'
     `*' マークの付いている一部だけが取得されたメッセージ群(`T')を取得
     する。
`C-umI'
     `mI' を実行する。
`M-b'
     `*' マークの付いたメッセージに格納されているメッセージを取り出す。
`M-\'
     `*' マークの付いたメッセージを引数として、外部コマンドを起動する。
`M-t'
     `*' マークの付いたメッセージを "uudecode" する。

`M-t' では、`*' マークの付いたメッセージがきちんと分割順になっている必
要があります。順番がくるっているなら、`S' でソートするとよいかもしれま
せん。



File: mew.jis.info, Node: escape mark, Next: unmark, Prev: target mark, Up: Marks

待避 `$'
========

たとえば `/' などを使いパターンに合致したメッセージに `*' を付けること
を考えて下さい。`*' マークの付いたメッセージがすでにあるなら、これらの
メッセージは `/' の結果と混ざってしまいます。そこで、現在の `*' マーク
を一時的に保存したくなります。

この目的のために、待避マーク `$' が提供されています。典型的な使い方は、
以下のようになります。

  1. `m$' で `*' マークを一旦 `$' マークに待避
  2. `/' などで `*' マークを付け、`*' マークのついたメッセージを処理
  3. `U*' で `*' マークを消去
  4. `m*' で `$' マークを `*' マークへ戻す

`$' マークに関するコマンドを以下にまとめます。

`m$'
     `*' マークを `$' マークへ変換。
`m*'
     `$' マークを `*' マークへ変換。



File: mew.jis.info, Node: unmark, Next: mark change, Prev: escape mark, Up: Marks

マークの消去
============

`o' マークや `D' マークが付いたメッセージは、マーク実行コマンド `x' を
押さない限り処理されません。よって、`x' を押す前に、マークを取り止める
コマンド `u' でマークを消せば、誤ってメッセージを消すことはありません。

以下にマークを消去するコマンドをまとめます。

`u'
     現在のメッセージのマークを消す。
`U'
     入力したマークが付いているすべてのメッセージのマークを消す。

`$' マークを使って `*' マークを待避し、なんらかの操作をし、元に戻す方法
は、目に見えるので分りやすいです。しかしながら、`$' マークが付いている
メッセージは、マークが付いているので目的の操作の対象外になるかもしれま
せん。

このため `U*' で消去した `*' マークを復活させるコマンドがあります。それ
は、`M*' です。この方法は、復活できるマークは目に見えないので分りにくい
かもしれません。しかしながら、マークが消えているので、そのメッセージは
確実に目的の操作の対象になります。

`M*'
     一番最後の `U*' で消した `*' マークを復活させる。




File: mew.jis.info, Node: mark change, Next: sync, Prev: unmark, Up: Marks

マークの変換
============

マークには強さのレベルがあります。同じレベルのマークは上書きできます。
強いマークは弱いマークを上書きできます。

マークを強い順に示します。

`o'、`D'、`X'
     新たにマークしたときは、次のメッセージを表示。上書きした場合は、そ
     の行に留まる。
`*' と `$'
     マークを付けた後は、その行に留まる。
`U'
     マークを付けた後は、その行に留まる。

強いマークを付けた後にカーソルが動く方向については、*Note
summary-mode:: を参照して下さい。

マークは以下のように交換できます。

`m$'
     `*' -> `$' :: `*' マークを一時的に保存。
`m*'
     `$' -> `*' :: `*' マークを元に戻す。
`ms'
     `$' <-> `*'
`mM-u'
     `*' -> `U' :: 選択コマンド `?' で選んだメッセージを未読にするとき
     に便利。
`md'
     `*' -> `D' :: 選択コマンド `?' で選んだメッセージを消去するときに
     便利。
`mM-d'
     `*' -> `X' :: 選択コマンド `?' で選んだメッセージを消去するときに
     便利。
`mo'
     `*' -> `o' :: 選択コマンド `?' で選んだメッセージをあるフォルダに
     移動させる場合に便利。
`mc'
     `*' -> `o' :: 選択コマンド `?' で選んだメッセージをあるフォルダに
     コピーする場合に便利。
`e'
     最初に入力したマークを次に入力したマークへ変換する。ただし、`o' マー
     クは対象外。



File: mew.jis.info, Node: sync, Next: off-line, Prev: mark change, Up: Marks

IMAP サーバとのマークの整合性
=============================

Mew では、以下のマークに対し、IMAP サーバと整合性を確保できます。

`U'
     メッセージを読んだか否か。IMAP のフラグは \Seen。通常は %inbox の
     みで有効。
`*'
     注目しているメッセージ。IMAP のフラグは \Flagged。

オフラインの操作を許すために、Mew ではユーザが動作を起こすたびに IMAP
サーバとマークの整合性を取ります。定期的に整合性を取ることはしません。
Mew がマークの整合性を取る方法を以下に示します。

  1. `s' + 'update
        - 既存のメッセージに対して変更したマークをサーバ側へ反映
        - 新着メッセージに対しては、サーバ側のフラグをマークへ反映

  2. `x'
        - 既存のメッセージに対して変更したマークをサーバ側へ反映

  3. `s' + 'sync
        - 既存のメッセージに対して変更したマークをサーバ側へ反映
        - 既存のメッセージの `*',`U', `$', ` ' マークを一旦クリア
        - サーバ側のフラグを既存のメッセージにマークとして反映
        - サーバ側で削除されたメッセージを削除



File: mew.jis.info, Node: off-line, Next: mew-mark, Prev: sync, Up: Marks

IMAP のためのマークのオフライン処理
===================================

IMAP ユーザは、フォルダ A のメッセージをキャッシュし、出先で `o' マーク
や `D' マークを付け、その場でそれらのマークを処理したくなることがありま
す。この場合、その後ネットワークに接続したときに、それらの処理が IMAP
サーバに反映されて欲しいと思います。

通常 IMAP では、メッセージをフォルダ A からフォルダ B へ移動させた場合、
フォルダ A にキャッシュされているそのメッセージを削除し、IMAP サーバか
らネットワークを通じ、フォルダ B へそのメッセージをキャッシュし直す必要
があります。なぜなら、フォルダ A にキャッシュされているメッセージに付随
する IMAP の情報は、フォルダ A 内でのみ有効だからです。

出先でフォルダ A のメッセージをフォルダ B へ整理したとしましょう。仮に、
そのメッセージをフォルダ B で読むためには、ネットワークに接続してその処
理を IMAP サーバに反映し、IMAP サーバから取り直さないといけないとすると
不便です。欲を言えば、出先でフォルダ B へ整理したメッセージは、IMAP サー
バから取り直さなくとも、フォルダ B へ移動すれば読めるようになっていて欲
しいと思います。

Mew では、メッセージ処理を後から IMAP サーバへ反映することと、IMAP サー
バからメッセージを再取得しなくても移動先のフォルダでメッセージを読める
ことの両方を実現しています。ネットワークに接続していない状況で、マーク
を処理するには、`lx' を使用して下さい。`lx' を実行すると、以下の処理が
なされます。

  1. `o' マークや `D' マークのついたメッセージがフォルダ A からなくなる。
  2. この処理はメッセージ形式で、%queue に溜る。
  3. `o' マークのついたメッセージは、ローカルでフォルダ B へ移動され、
     無効なメッセージとして扱われる。

無効なメッセージとは、読むことはできるが、`o' マークや `D' マークをつけ
られないものをいいます。無効なメッセージには、`#' マークが付いています。
`g' を使って、フォルダ B へ行くと、無効なメッセージの一覧が自動的に表示
されます。

ネットワークに接続した後に、%queue に溜っている処理を IMAP サーバに反映
させるには、%queue で `C-cC-c' と入力して下さい。

IMAP サーバに処理を反映した後に、フォルダ B で `s' を押すと、無効なメッ
セージが削除され、有効なメッセージがキャッシュされます。



File: mew.jis.info, Node: mew-mark, Next: Refile, Prev: off-line, Up: Marks

Mew が表示するマーク
====================

以下に Mew が表示するマークをまとめます。

`M'
     マルチパートを表すマーク。*Note multipart:: を参照のこと。
`-'
     Multipart/Alternative を表すマーク。*Note analysis:: を参照のこと。
`T'
     メッセージが切り詰められたことを表すマーク。*Note retrieving:: を
     参照のこと。
`S'
     署名を表すマーク。*Note cipher-viewing:: を参照のこと。
`E'
     暗号化を表すマーク。*Note cipher-viewing:: を参照のこと。
`P'
     分割されていることを示すマーク。*Note target mark:: を参照のこと。
`#'
     メッセージが無効であることを示すマーク。*Note off-line:: を参照の
     こと。




File: mew.jis.info, Node: Refile, Next: by-folder, Prev: mew-mark, Up: Top

楽々整理整頓
************

1 日に数百のメッセージを受け取るようになると整理整頓が大変になります(え、
そんなに受け取らないですって？ 幸せですね :) 。Mew では、`o' でメッセー
ジを整頓する際に、整頓先を推測し初期値として表示してくれます。たとえば、
次のようになります。

     Folder name (+work/mew-dist): +

もし、() の中の初期値が自分の希望通りであれば、`RET' を押すだけでよいの
です。整頓先が決定しているメッセージには、`o' マークが付きます。

メッセージを移動できるのは、そのメッセージが属している「世界」の中での
みです。前述のように世界はケースと修飾子によって定まります。整頓先のフォ
ルダを指定する場合には、ケースを付けず、同じ修飾子を持つフォルダ名を入
力する必要があります。ケースを付けない理由は、そのメッセージのケースは
すでに定まっているからです。ミニバッファからフォルダ名を入力する際、ケー
スが "default" でないにも関わらずケースを明示的に入力しないのは、整頓先
を指定する場合のみです。

`o' に似たコマンドに `c' があります。両者の違いは、
*Note refile mark:: を参照して下さい。

この整頓先の推測が賢ければ賢い程ユーザは楽になります。Mew では以下のよ
うな規則が用意されています。

* Menu:

* by-folder::                   メーリングリスト用のフォルダから推測
* by-alist::                    指定した規則から推測
* by-thread::                   対話関係から推測
* by-from-folder::              個人用のフォルダから推測
* by-from::                     From: から推測
* by-newsgroups::               Newsgroups: から推測
* by-default::                  デフォルトの規則
* guess-rule::                  規則の制御
* auto-refile::                 自動で整理整頓
* copy-msg::                    世界を越えたメッセージのコピー



File: mew.jis.info, Node: by-folder, Next: by-alist, Prev: Refile, Up: Refile

メーリングリスト用のフォルダから推測
====================================

あるメーリングリスト宛のメッセージを、そのメーリングリスト名のフォルダ
に整理することは多いと思います。Mew ではメーリングリスト宛に届いたメッ
セージに対して、それ用のフォルダを推測する機能があります。

たとえば、+misc/pooh-lovers というフォルダがあったとしましょう。次のよ
うなメッセージは、このフォルダに整頓すればよい可能性が高いといえます。

     To: pooh-lovers@example.org

このように、To: や Cc: のアドレスが、フォルダ名の一番右側にマッチするも
のがないか探すわけです。フォルダを階層化していない人が多いようですが、
Mew を使う限り、階層化しない手はありません。

さて、鋭い人は次のように個人のアドレスが To: や Cc: にある場合、困るの
ではないかと思うでしょう。

     To: piglet@example.org
     Cc: pooh-lovers@example.org

たとえば、pooh は pooh-lovers の一員ですから、このメッセージが届きます。
しかし、piglet と仲がいいので、+from/piglet にマッチしてしまいます。

そこで、Mew では無視するフォルダを設定できるようになっています。デフォ
ルトでは、+from 以下を無視します。ですから、個人からのメッセージは
+from 以下に収めて下さい

候補が決定できたら

     Folder name (+misc/pooh-lovers): +

と訊いてきます。あっていれば `RET' を、違っていればお望みのフォルダを入
力して下さい。

`o' で新しいフォルダを指定すると、そのフォルダが自動的に作成され、次か
らは推測用の候補にも加わります。便利でしょ？

この機能を提供する関数は `mew-refile-guess-by-folder' です。

もし、フォルダ名に大文字を使っていないなら、以下の設定により、この関数
が高速になります。

     (setq mew-use-fast-refile t)

デフォルトでは、末端のフォルダと中間のフォルダが候補の対象となっていま
す。もし、中間のフォルダではなく、末端のフォルダだけを選びたい場合は、
以下のように設定して下さい。

     (setq mew-use-node-folder nil)



File: mew.jis.info, Node: by-alist, Next: by-thread, Prev: by-folder, Up: Refile

指定した規則から推測
====================

フォルダ名から推測する機能だけでは、思うようなフォルダを推測してくれな
い場合があります。たとえば、To: が staff@example.jp であるメッセージと
To: が staff@example.net であるメッセージに対し、フォルダ名からの推測で
は同じフォルダ(たとえば、"+net/staff")が選ばれてしまいます。そこで、
Mew では、変数 `mew-refile-guess-alist' に明示的に規則を設定できます。
(`mew-refile-guess-alist' は、必ず新しい書式で書いて下さい。詳しくは
*Note config2:: を参照のこと。)

1 つ例を挙げてみましょう。

     (setq mew-refile-guess-alist
       '(("To:"
           ("staff@example.jp"  "+jp/staff")
           ("staff@example.net" "+net/staff"))))

これは、メッセージヘッダ中の To: の横の文字列に staff@example.jp があれ
ば +jp/staff へ、staff@example.net があれば +net/staff へ整頓するという
意味です。

規則は、以下のように書きます。

     rule ::= '<rule>
     <rule> ::= ((<key> <alist>) (<key> <alist>) ... [<special>])

全体は (<key> <alist>) のリストです。<key> はフィールド名を書きます。
<alist> は以下のようになります。

     <alist> ::= (<value> <folder>|<rule>) (<value> <folder>|<rule>) ...

<value> は <key> で示したフィールドにくる値です。<folder> は <key> にマッ
チした際にどのフォルダに整頓するかを意味しています。<folder> の代りに
<rule> を再帰的に記述することもできます。

特殊な <key> として `nil' と `t' があります。`nil' は、何も推測できなかっ
た場合に返す <folder> を指定するために用います。`t' は、推測した値に加
えて返す <folder> を指示するために使います。

     <special> ::= (t <folder>) | (nil <folder>)

正規表現を知っている人は、以下のような複雑な規則を設定できます。

     (setq mew-refile-guess-alist
       '(("Newsgroups:"
         ("^nifty\\.\\([^ ]+\\)" "+Nifty/\\1")
         (".*"                   "+rec/news"))
        ("To:"
         ("\\(inet\\|wide\\)@wnoc-fuk" "+wide/\\1-wnoc-fuk"))
        ("From:"
         ("uucp@"    "+adm/uucp")
         ("ftpsync@" "+adm/ftpsync"))
        (nil "+unknown")))

この機能を提供する関数は `mew-refile-guess-by-alist' です。



File: mew.jis.info, Node: by-thread, Next: by-from-folder, Prev: by-alist, Up: Refile

対話関係から推測
================

Mew には、整頓しようとしているメッセージの親のメッセージが以前整頓され
たフォルダを選択してくれる機能があります。

たとえば、pooh、piglet、roo との間で、蜂蜜を取りに行こうという話題が盛
り上がったとしましょう。pooh は、+project/honey というフォルダを作って、
最初のメッセージをそこに整頓したとしましょう。以降、3 人の間のメッセー
ジがきちんとした返答であるかぎり、+project/honey を推測してくれます。

あるメッセージをどこに保存したかという情報は、
"~/Mail/.mew-refile-msgid-alist" に保存されています。この情報を過去
何通のメッセージに関して保存するかは、`mew-lisp-max-length' で決定
します。初期値は 2000 通です。3000 通にしたい場合は "~/.mew.el" 中で以
下のように設定して下さい。

     (setq mew-lisp-max-length 3000)

この機能を提供する関数は `mew-refile-guess-by-thread' です。



File: mew.jis.info, Node: by-from-folder, Next: by-from, Prev: by-thread, Up: Refile

個人用のフォルダから推測
========================

*Note by-folder:: で説明したメーリングリスト用のフォルダを推測するに加
えて、個人用のフォルダを推測する機能があります。個人用のフォルダは
+from 以下にありますから、+from 以下のフォルダを選択する機能だともいえ
ます。以下の例を考えてみましょう。

     To: pooh@example.net
     From: piglet@example.org

piglet から pooh にメッセージが来ました。pooh がこの機能を使うと、
From: を手がかりに +from/piglet が選択されます。(+from 以下は階層化され
ていても構いません。また、フォルダ名はユーザ名だけではなくアドレス全体
でも OK です。)

この機能を提供する関数は、`mew-refile-guess-by-from-folder' といいます。

次に、pooh が piglet に返答した場合を考えましょう。pooh は自分自身に
Cc: していたので、自分にメッセージが戻ってきました。

     To: piglet@example.org
     Cc: pooh@example.net
     From: pooh@example.net

pooh の立場になって考えてみて下さい。このメッセージを +from/pooh に整頓
するか、あるいは +from/piglet に整頓するのかは、好みが分かれるところで
しょう。そこで、どちらを選択するのかカスタマイズできるようになっていま
す。

`mew-refile-guess-from-me-is-special' が `t' なら、
`mew-refile-guess-by-from-folder' は、From: が自分のアドレスの場合に、
To: と Cc: にあるアドレスをもとに、+from 以下のフォルダを選択します。



File: mew.jis.info, Node: by-from, Next: by-newsgroups, Prev: by-from-folder, Up: Refile

From: から推測
==============

From: に同一のアドレスを持つメッセージが、かつてどこに整頓されたかによっ
て推測する機能があります。

たとえば、piglet は piglet@example.org と p-p-p@example.org の 2 つのア
ドレスを持っているとしましょう。どちらのアドレスからメッセージが届いて
も、pooh はそれらを +from/piglet に整頓したいと思っています。もちろん、
以下のように明示的に規則を書けば実現できます。

     (setq mew-refile-guess-alist
       '(("From:"
           ("piglet@example.org" "+from/piglet")
           ("p-p-p@example.org"  "+from/piglet"))))

しかし、いちいち規則を書くのは面倒です。そこで、まず From: が
piglet@example.org であるメッセージを +from/piglet に整頓します。これで
フォルダ +from/piglet が作成されます。次に、From: が p-p-p@example.org
であるメッセージを +from/piglet に整頓したとします。ここで Mew は、
p-p-p@example.org が +from/piglet に整頓されたことを学習します。以後
From: が p-p-p@example.org であるメッセージを整頓しようとすると、
+from/piglet を選択するようになります。

その他、機械からくるメッセージは、いつも +adm/misc に入れることにしたい
場合なども、明示的な規則を書かずに済ませられます。

From: とフォルダの情報は、"~/Mail/.mew-refile-from-alist" に保存されてい
ます。この情報を過去何通のメッセージに関して保存するかは、
*Note by-thread:: と同様に `mew-lisp-max-length' で決定します。

この機能を提供する関数は `mew-refile-guess-by-from' です。

`mew-refile-guess-from-me-is-special' が `t' の場合、
`mew-refile-guess-by-from' は `mew-refile-guess-by-from-folder'(*Note
by-from-folder::)と同様な動きをします。



File: mew.jis.info, Node: by-newsgroups, Next: by-default, Prev: by-from, Up: Refile

Newsgroups: から推測
====================

ニュースをメールとして受信して Mew で読んでいる人のために、Newsgroups:
からフォルダを推測する機能を用意しました。関数名は
`mew-refile-guess-by-newsgroups' です。



File: mew.jis.info, Node: by-default, Next: guess-rule, Prev: by-newsgroups, Up: Refile

デフォルトの規則
================

デフォルトの規則は、From: からユーザ名を切り出して、`+from/user'
を選ぶようになっています。ただし、
`mew-refile-guess-strip-domainpart' が `nil' ならアドレスを切
り出すので、`+from/user@domain' が選択されます。
`mew-refile-guess-strip-domainpart' の初期値は `t' です。

関数名は、`mew-refile-guess-by-default' です。



File: mew.jis.info, Node: guess-rule, Next: auto-refile, Prev: by-default, Up: Refile

規則の制御
==========

Mew では、フォルダ推測の規則を 2 つの変数、`mew-refile-guess-control'
と `mew-refile-ctrl-multi' で制御します。`mew-refile-guess-control' は、
呼び出す関数を順に定義します。候補を複数にしたい場合は
`mew-refile-ctrl-multi' を `t' に、単数にしたい場合は `nil' に設定しま
す。

標準では、`mew-refile-guess-control' は以下のように宣言されています(宣
言なので `defvar' が使われています)。

     (defvar mew-refile-guess-control
       '(mew-refile-guess-by-alist
         mew-refile-ctrl-throw
         mew-refile-guess-by-newsgroups
         mew-refile-guess-by-folder
         mew-refile-ctrl-throw
         mew-refile-ctrl-auto-boundary
         mew-refile-guess-by-thread
         mew-refile-ctrl-throw
         mew-refile-guess-by-from-folder
         mew-refile-ctrl-throw
         mew-refile-guess-by-from
         mew-refile-ctrl-throw
         mew-refile-guess-by-default))

Mew は `mew-refile-guess-control' に並べられた関数を順番にすべて実行し
ます。各々の関数が複数の候補を推測することがあります。

`mew-refile-guess-control' の動作例として以下を考えてみましょう。

`mew-refile-guess-by-alist'
         が +aaa、+bbb を推測。
`mew-refile-guess-by-folder'
         が +ccc、+ddd を推測。
`mew-refile-guess-by-default'
         が +eee を推測。

+aaa 〜 +eee すべてをユーザに提示して欲しい場合は、
`mew-refile-ctrl-multi' を `t' に、+aaa だけを提示して欲しい場合は、
`nil' に設定します。

また、+aaa 〜 +ddd は提示して欲しいけれどもそれ以降はいらない、つまり、
+eee を提示するのは先に実行された関数群が何も推測できなかったときだけに
したい場合は、`mew-refile-ctrl-multi' を `t' にして、
`mew-refile-guess-by-folder' と `mew-refile-guess-by-default' の間に
`mew-refile-ctrl-throw' を入れて下さい。

`C-uo' は、この推測の流れを Message バッファに表示します。



File: mew.jis.info, Node: auto-refile, Next: copy-msg, Prev: guess-rule, Up: Refile

自動で整理整頓
==============

毎日メッセージをたくさんもらう人は、まだ整頓していないメッセージを
+inbox (あるいは %inbox) フォルダに大量に溜めてしまうことがあります。そ
んなときは、「メッセージ達よ、とにかくこのフォルダからどこかに行ってし
まえ」と叫びたくなることがあるでしょう。Mew は、そんなわがままな人を満
足させるための自動整理整頓関数を提供しています。:) `M-o' がその呪文です。

この関数を実行すると、現在のフォルダ内の特定のメッセージに対して、自動的
に `o' マークを付けてくれます。特定のメッセージとは、
`mew-refile-auto-refile-skip-any-mark' が `nil' なら、`o'
や `D' マークが付いていないメッセージです。
`mew-refile-auto-refile-skip-any-mark' が `t' なら、なにもマー
クが付いてない(既読)メッセージです。
`mew-refile-auto-refile-skip-any-mark' の初期値は `nil' です。

`C-uM-o' は、`mew-refile-auto-refile-skip-any-mark' の値とは関係なく
`*' マークの付いたメッセージを対象にします。

整頓先の決定には、先に説明した推測関数群が働くようになっています。この
関数は、`o' を付けるだけですので、`x' を押さない限り実際にメッセージが
どこかに行ってしまうことはありません。

Mew の整頓先推測はあまりにも賢すぎるので、この機能には仇となってしまい
ます。というのは、Mew が推測機能をフルに使って勝手に整頓してしまうと、
大抵のユーザはどこにメッセージが整頓されたか分からなくなってしまうから
です。:) そのために、Mew が使う推測関数を制限する機能が提供されています。
前に出てきた宣言をもう一度思い出して下さい。

     (defvar mew-refile-guess-control
       '(mew-refile-guess-by-alist
         mew-refile-ctrl-throw
         mew-refile-guess-by-newsgroups
         mew-refile-guess-by-folder
         mew-refile-ctrl-throw
         mew-refile-ctrl-auto-boundary
         mew-refile-guess-by-thread
         mew-refile-ctrl-throw
         mew-refile-guess-by-from-folder
         mew-refile-ctrl-throw
         mew-refile-guess-by-from
         mew-refile-ctrl-throw
         mew-refile-guess-by-default))

`mew-refile-guess-control' の中に `mew-refile-ctrl-auto-boundary' とい
う関数があります。これがその仕掛です。自動整理整頓のときに限り、Mew は
この関数より下に記述してある推測を無視します。
`mew-refile-ctrl-auto-boundary' より上に記述している関数が何も推測でき
なかった場合は、そのメッセージには `o' が付きません。破滅が訪れる前に
`mew-refile-ctrl-auto-boundary' の御札を貼って下さい。




File: mew.jis.info, Node: copy-msg, Next: Virtual, Prev: auto-refile, Up: Refile

世界を越えたメッセージのコピー
==============================

これまで説明した整頓とは、同じ世界の中でメッセージを移動させることでし
た。これに対し、ある世界から他の世界へメッセージを移動させたいこともあ
るでしょう。これは、ある世界から他の世界へメッセージへコピーし、その後
元のメッセージを削除することで実現できます。ここでは、ある世界から他の
世界へメッセージへコピーする方法について説明します。

あるフォルダのメッセージをローカルフォルダへコピーしたくなることがあり
ます。この場合 `lc' を利用して下さい。`lc' は、リモート・フォルダで実行
された場合、キャッシュされたメッセージから、そのリモート・フォルダに特
有の情報をヘッダから取り除き、ローカル・フォルダへコピーします。(`lc'
は、ローカルフォルダでも実行できます。この場合、同じ世界内でのコピーに
なります。)

あるフォルダのメッセージを IMAP のフォルダ(サーバ側)へコピーするには、
`li' を利用します。

`*' の付いた複数のメッセージをローカル・フォルダへコピーするには`mlc'
を使います。また、`*' の付いた複数のメッセージを IMAP フォルダへコピー
するには `mli' を利用して下さい。

ある世界から他の世界へメッセージへコピーするコマンドを以下にまとめます。

`lc'
     あるフォルダのメッセージをローカルフォルダへコピーする。
`mlc'
     `*' の付いた複数のメッセージをローカル・フォルダへコピーする。
`li'
     あるフォルダのメッセージを IMAP のフォルダへコピーする。
`mli'
     `*' の付いた複数のメッセージを IMAP フォルダへコピーする。




File: mew.jis.info, Node: Virtual, Next: selection, Prev: copy-msg, Up: Top

仮想フォルダ
************

Virtual モードは、必要なメッセージを表示するための仮想的なフォルダであ
り、「セレクション」と「スレッド」の2種類に分類できます。

`セレクション'
     いろいろなフォルダから必要なメッセージだけを集めた仮想フォルダです。
     フォルダ名の左側に "*" が付きます。
`スレッド'
     フォルダ(Summary)やセレクション(Virtual)を基に、対話関係を行頭揃え
     によって可視化した仮想フォルダです。フォルダ名の両側に "*" が付き
     ます。

Summary モードで利用できるコマンドの多くが、Virtual モードで利用できま
す。

Virtual モードでメッセージにマークを付けると、対応する Summary モードが
あれば、そちらのメッセージにもマークが付きます。逆に、Summary モードで
あるメッセージにマークを付けても、Virtual モードの対応するメッセージに
はマークは付きません。

Virtual モードからマークを処理することはできません。`x' を押しマークを
処理しようとすると、対応する Summary モードがあれば、そちらに移動し、も
う一度 `x' を押すよう促されます。

仮想フォルダはまさしく仮想であり、ファイルシステムなどには存在しないこ
とに注意して下さい。Emacs を終了すると、仮想フォルダはなくなります。
Virtual モードを消去する方法については、*Note Quit:: を参照して下さい。

* Menu:

* selection::                   セレクション
* sorting::                     ソート
* dialog::                      対話
* search::                      検索
* condition::                   検索条件の入力方法
* dbsearch::                    検索エンジン
* keyword::                     キーワードの強調
* thread::                      スレッド
* thread-op::                   スレッドの操作



File: mew.jis.info, Node: selection, Next: sorting, Prev: Virtual, Up: Virtual

セレクション
============

セレクションは、いろいろなフォルダから必要なメッセージだけを集めた仮想
フォルダです。セレクションの作り方には、以下の 5 つがあります。

`m/'
     あるフォルダで、"*" マークが付いているメッセージのみを表示する。
`S'
     あるフォルダで、メッセージをソートして表示する。(元のフォルダには、
     何の影響もない。) *Note sorting:: を参照のこと。
`V'
     現在のメッセージと対話関係にあるメッセージを表示する。*Note
     dialog:: を参照のこと。
`/'
     あるフォルダから、検索条件に合致するメッセージを表示する。*Note
     search:: を参照のこと。
`k/'
     すべてのフォルダから、検索条件に合致するメッセージを表示する。
     *Note dbsearch:: を参照のこと。




File: mew.jis.info, Node: sorting, Next: dialog, Prev: selection, Up: Virtual

ソート
======

メッセージをソートしセレクションを作成するには `S' を使います。このとき
次のようにどのフィールドでソートするか訊いてくるので、ソートしたいフィー
ルド名を入力して下さい。

     Sort by? (default date):

指定したフィールドに書かれている文字列は単純に文字列比較でソートするべ
きではありません。たとえば、Subject: はテキストと考えてよいのですが、
Date: は日付、X-Mail-Count: は数字と考えてソートすべきです。このように
文字列をどう取り扱うかをモードといいます。ソートによく指定されるフィー
ルド名に対するモードは `mew-sort-key-alist' で設定されています。

ソートのモードを明示的に指定、変更したい場合には `:' で区切って指定しま
す。たとえば X-Mail-Count: フィールドの内容を(テキストとしてではなく)
数値とみなしてソートしたい場合には、次のように入力します。

     x-mail-count:num

フィールド名やモードは `TAB' で補完できます。

モードには、以下の 4 つがあります。

`text'
     先頭の "Re: " や "Fw: " を取り除いた文字列。
`ml'
     text と同じであるが、さらにメーリングリスト特有の文字列も取り除く。
`num'
     数値。
`date'
     日付。

"Sort by?" と訊かれる際のフィールド名の初期値は、
`mew-sort-default-key' で設定できます。以下は、初期値である"date"
を "x-ml-count" に変更する例です。

     (setq mew-sort-default-key "x-ml-count")

`mew-sort-default-key-alist' で、フォルダごとにフィールド名の初期
値を設定することもできます。ここで指定しなかったフォルダでは、フィール
ド名の初期値として `mew-sort-default-key' の値が使われます。以下は、
+inbox フォルダでの初期値を "subject" に、+mew-dist フォルダでの初期値
を "x-mail-count" に変更する例です。

     (setq mew-sort-default-key-alist
           '(("+inbox" "subject")
             ("+mew-dist" "x-mail-count")))

なお、ローカル・フォルダでメッセージを本当にソートするためには`M-s' を
使って下さい。このコマンドは、リモート・フォルダでは利用できません。



File: mew.jis.info, Node: dialog, Next: search, Prev: sorting, Up: Virtual

対話
====

Mew では、あるメッセージに関係するメッセージをさまざまなフォルダから集
めて仮想フォルダに一覧表示できます。これを「対話」と呼びましょう。後ほ
ど説明するスレッド(*Note thread::)とは、以下の点で異なります。


   - スレッドは、1つのフォルダ/仮想フォルダに対してのみ作成できる。対話
     は、関連するメッセージが複数のフォルダに散らばっていてもよい。

   - スレッドは、行頭揃えによって木構造を可視化する。対話は、日付順に一
     覧表示する。

対話の機能を使うには、まず `kI' を実行し、データベースを作る必要が
あります。新しく届くメッセージはデータベースに入らないので、`kI'
は定期的に実行して下さい。`kI' は、データベースを差分更新します。
この方式は早いのですが、ゴミが残ることは避けられないので、ときどき
`C-ukI' を実行し、データベースを一から作り直して下さい。

対話を作成するには、注目しているメッセージの上で `V' を押します。
このコマンドは、自分の子孫と、自分の先祖、そして自分だけを表示します。
自分の兄弟などは表示しません。一族全体を表示したいなら、一旦作った仮想
フォルダの一番上にあるメッセージ、すなわち一族の祖の上で、もう一度
`V' を実行して下さい。



File: mew.jis.info, Node: search, Next: condition, Prev: dialog, Up: Virtual

検索
====

Mew では、以下のようなメッセージの検索機能を提供しています。

`?'
     現在のフォルダで、条件に合致したメッセージに `*' マークを付ける。
     入力された条件によって、`mewl' か `grep' のどちらかが呼ばれる。
`C-u?'
     リージョンを指定した `?'。
`/'
     現在のフォルダで、条件に合致したメッセージからセレクションを作る。
     入力された条件によって、`mewl' か `grep' のどちらかが呼ばれる。
`C-u/'
     リージョンを指定した `C-u/'。

また、Spotlight や Windows Desktop Search などの検索エンジンを利用した
検索も可能です。これには、以下のコマンドがあります。

`k?'
     現在のフォルダで、条件に合致したメッセージに `*' マークを付ける。
`k/'
     全フォルダに対し、条件に合致したメッセージからセレクションを作る。
`C-uk/'
     指定されたフォルダに対し、条件に合致したメッセージからセレクション
     を作る。フォルダを複数指定するには "," で区切る。ワイルドカードと
     して、"*" を利用できる。



File: mew.jis.info, Node: condition, Next: dbsearch, Prev: search, Up: Virtual

検索条件の入力方法
==================

`?' や `/' を実行すると、Mew はユーザに対し以下のように検索のパターンを
訊きます。

     mewl/grep pick pattern:

単純に「文字列」を 1 つ入力すると、Mew は `grep' を呼び出します。また、
「条件式」を入力すると、`mewl' を呼び出します。

条件式の書式を以下に示します。(結合力の強い順に並んでいます。)

`field=string'
     フィールド field に文字列 string が含まれているときマッチ(大文字小
     文字を区別しない)。field に "head" を指定した場合は、ヘッダ全体を
     意味する。
`field==string'
     フィールド field に文字列 string が含まれているときマッチ(大文字小
     文字を区別する)。field に "head" を指定した場合は、ヘッダ全体を意
     味する。
`field!=string'
     フィールド field に文字列 string が含まれていないときマッチ(大文字
     小文字を区別しない)。field に "head" を指定した場合は、ヘッダ全体
     を意味する。
`field!==string'
     フィールド field に文字列 string が含まれていないときマッチ(大文字
     小文字を区別する)。field に "head" を指定した場合は、ヘッダ全体を
     意味する。
`( <pattern> )'
     <pattern> の内容を先に評価。
`! <pattern>'
     <pattern> でないときマッチ。
`<pattern1> & <pattern2>'
     <pattern1> かつ <pattern2> のときマッチ。省略可能。
`<pattern1> | <pattern2>'
     <pattern1> または <pattern2> のときマッチ。

以下に例を示します。

(a) From: に kazu が含まれるメッセージ

     from=kazu

(b) To: が mew、または、Cc: が mew であるメッセージ

     to=mew | cc=mew

(c) To: が mew、または、Cc: が mew で、かつ、from が kazu であるメッセー
ジ

     (to=mew | cc=mew) & from=kazu

`?' や `/' で、パターンに入力の際に単純に `RET' を押すと、以下のように
利用するコマンドまで入力できるようになります。

     Cmd opts pattern: grep -l -e

`k?' や `k/' で検索エンジンを利用する場合は、上記のパターン(文字列や条
件式)が自動的に検索エンジンの書式に変換されます。

たとえば、kazu から来たメールで、「wine」を含み、かつ「bordeaux」を含ま
ないという条件式は以下のように書きます。

     from=kazu wine ! bordeaux

なお、`mew-pick-pattern-list' にパターンのリストを定義しておくと、
`C-cTAB' で各要素を循環的に補完できます。この場合、リストの先頭がデフォ
ルトとして表示されます。

日本語の全文検索をしたい場合は、("grep" の代わりに) "mg" をインストール
し、以下のように設定して下さい。

     (setq mew-prog-grep "mg")
     (setq mew-prog-grep-opts '("-j" "jis" "-l" "-e" "-x" "&mime"))



File: mew.jis.info, Node: dbsearch, Next: keyword, Prev: condition, Up: Virtual

検索エンジン
============

検索エンジンを操作するために以下のコマンドが用意されています。

`km'
     そのフォルダのインデックスを作る。
`kM'
     全体のフォルダのインデックスを作る。あるいは、作るために初期化する。
`kc'
     検索エンジンを切り替える。

以下に、それぞれの検索エンジンの説明を示します。

`Hyper Estraier'
     定期的に `kM' を実行する必要があります。コマンドラインで、
     mewest" を実行しても構いません。あるフォルダのインデックスを急いで
     更新したいなら `km' でもよいでしょう。`k?' と`k/' の両方が利用でき
     ます。`C-uk/'でフォルダを指定すると、サブディレクトリも検索になり
     ます。
`Spotlight'
     一度だけ `kM' を実行する必要があります。`km' は必要ありません。
     `k?' と `k/' の両方が利用できます。
`Windows Desktop Search'
     一度だけ `kM' を実行する必要があります。`km' は必要ありません。
`Google Desktop'
     一度だけ `kM' を実行する必要があります。`km' は必要ありません。
     `k/' のみが利用できます。

検索エンジンの初期値は、最初に見つかった利用できるものに自動的に設定さ
れます。明示的に指定したい場合は、`mew-search-method'
に'est、'spotlight、'wds, 'google のどれかを指定して下さい。以下は、
Hyper Estraier に設定する例です。

     (setq mew-search-method 'est)



File: mew.jis.info, Node: keyword, Next: thread, Prev: dbsearch, Up: Virtual

キーワードの強調
================

検索に使ったキーワードは、バッファに保存されています。メッセージを表示
し、さらにキーワードをハイライトすることができます。この機能を提供する
コマンドは以下の通りです。

`M-n'
     下方向のメッセージへ移動しキーワードをハイライトして表示。Summary
     モードでは `*' マークのついたメッセージが、Virtual モードではすべ
     てのメッセージが対象となる。このコマンドを繰り返し利用すると、キー
     ワードの付近が次々と表示されていく。キーワードが設定されていないな
     ら、ユーザにキーワードを訊く。
`C-uM-n'
     キーワードを明示的に設定できること以外は、`M-n' に同じ。
`M-p'
     `M-n' を逆方向にしたコマンド。
`C-uM-p'
     `C-uM-n' を逆方向にしたコマンド。



File: mew.jis.info, Node: thread, Next: thread-op, Prev: keyword, Up: Virtual

スレッド
========

メッセージをやりとりしていると、対話の流れは木構造になります。これを行
頭揃えにより可視化したものをスレッドと呼びます。以下にスレッドの例を示
します。

       03/12 Hidenori Ohta  今週末                    |日曜にストーンマジック
       03/13 かずくん       ┣Re: 今週末              |雨なので、中にしますか
       03/15 Hidenori Ohta  ┃┗Re: 今週末            |それでは、12:00 に集合
       03/14 おだちゃん     ┗Re: 今週末              |いいねぇ。次はあれを落

スレッドは仮想フォルダとして実現されています。たとえば、+inbox に対しス
レッドを作ると、*+inbox* というバッファが用意されます。

スレッドを作るために、以下のコマンドが用意されています。

`tt'
     Summary モード、あるは、セレクションからスレッドを作る。そして、カー
     ソルを現在のメッセージに移動する。もし、対応するスレッドがすでに存
     在しているなら、スレッドに表示を切り替える。スレッドで使用された際
     は、元のフォルダへ移り、カーソルを現在のメッセージへ移動する。
`C-utt'
     リージョンに対し、スレッドを作る。
`mt'
     `*' マークの付いているメッセージに対し、スレッドを作る。
`tr'
     正規表現に合致したメッセージに対し、スレッドを作る。



File: mew.jis.info, Node: thread-op, Next: Quit, Prev: thread, Up: Virtual

スレッドの操作
==============

スレッドに特化した移動コマンドを以下に示します。

`tp'
     現在のスレッドの頭に移動する。もし、あるスレッドの頭にカーソルがあ
     る場合は、前のスレッドの頭に移動する。
`tn'
     次のスレッドの頭に移動する。
`^'
     親のメッセージに移動する。(スレッドでなくても利用可能)
`&'
     長男のメッセージに移動する。(スレッドでなくても利用可能)
`('
     兄のメッセージに移動する。
`)'
     弟のメッセージに移動する。


スレッドにマークを付けるコマンドを以下に示します。

`t*'
     現在のメッセージを頭とする部分木に属するメッセージすべてに `*' マー
     クを付ける。詳しくは *Note target mark:: を参照のこと。
`t$'
     現在のメッセージを頭とする部分木に属するメッセージすべてに `$' マー
     クを付ける。詳しくは *Note escape mark:: を参照のこと。
`td'
     現在のメッセージを頭とする部分木に属するメッセージすべてに `D' マー
     クを付ける。詳しくは *Note delete mark:: を参照のこと。
`tM-d'
     現在のメッセージを頭とする部分木に属するメッセージすべてに `X' マー
     クを付ける。詳しくは *Note delete mark:: を参照のこと。
`to'
     現在のメッセージを頭とする部分木に属するメッセージすべてに `o' マー
     クを付ける。詳しくは *Note refile mark:: を参照のこと。

スレッドからマークを消すコマンドは、`tu' です。


以下に、スレッドを加工するコマンドを示します。

`tSPC'
     子供以下を隠して親だけにする。子供以下が隠れている親メッセージには、
     +" が付く。また、子供以下が隠れている親メッセージでこのコマンドを
     実行すると、子供以下が現れる。
`ta'
     すべてのスレッドに対し、子供の表示を反転させる。
`tg'
     あるスレッドをあるメッセージに接ぎ木する。接ぎ木するスレッドは、
     `C-SPC' で指定する。目的のスレッドの一番上のメッセージで、`C-SPC'
     を押すと、そのスレッドが選択されたことになる。そして目的のメッセー
     ジへ移動し、`tg' を押すと、スレッドがこのメッセージの子供として接
     ぎ木される。


なお、`mew-use-thread-separator' を `t' にすると、スレッド間に境界文字
列として `mew-thread-separator' (初期値は "--") が挿入されます。




File: mew.jis.info, Node: Quit, Next: Customize, Prev: thread-op, Up: Top

一休み
******

Mew を終了させたり、一時中断させたり、そのモード(正確にはバッファ)を消
去する方法を以下に示します。

<Summary モードと Virtual モード>

`q'
     Mew を一時中断し、他のバッファに切り替える。Mew 用のバッファはすべ
     て残っているので、バッファ操作で選べば再開できる。
`Q'
     Mew を終了。Mew が使ったすべてのバッファを消去する。
`C-cC-q'
     そのモード(正確にはバッファ)を消去する。

<Draft モードと Header モード>

`C-cC-q'
     その草稿を消去する。

<Addrbook モード>

`C-cC-q'
     そのバッファを消去する。




File: mew.jis.info, Node: Customize, Next: summary-mode, Prev: Quit, Up: Top

カスタマイズ
************

ここでは、Mew のデフォルトの動作を変更し、自分好みの Mew にする方法を説
明します。主に "~/.mew.el" で設定して下さい。

* Menu:

* summary-mode::                Summary mode
* message-mode::                Message mode
* draft-mode::                  Draft mode
* charset::                     文字コード
* highlight::                   色付け
* hooks::                       フック
* pop::                         POP
* imap::                        IMAP
* nntp::                        NNTP
* smtp::                        SMTP
* config::                      送受信の動作変化
* config2::                     設定の書式
* custom-misc::                 その他



File: mew.jis.info, Node: summary-mode, Next: message-mode, Prev: Customize, Up: Customize

Summary mode
============

Summary モードの書式は、`mew-summary-form' で指定できます。以下に初期値
を示します。

     (setq mew-summary-form '(type (5 date) " " (14 from) " " t (30 subj) "|" (0 body)))

このように、`mew-summary-form' は、リスト、シンボル、文字列のリストです。

  1. 文字列はそのまま出力される
  2. リストは、整数とシンボルから構成される。シンボルは、呼び出す関数を
     意味する。関数名は、"mew-summary-form-" とシンボル名を連結すること
     で作られる。(例： 'date というシンボルは、`mew-summary-form-date'
     という関数名になる) あらかじめ定義されているシンボルに
     は、'type、'time、'date、'year、'size、'from、'subj、'body がある。
     詳細は、`mew-summary-form-<symbol>' という名を持つ関数の説明を参照
     のこと。整数は、関数が返す文字列が埋めるフィールドの幅を指定する。
     正の数は、左詰めを意味する。負の数は、右詰めを意味する。もし、負の
     数を指定する場合、対応する関数は ASCII 文字列を返す必要がある。0
     は、行の残りを意味し、左詰めとなる。
  3. `t' 以外のシンボルは、(1 シンボル) に等しい。
  4. `mew-summary-form' は、利用される際に先頭に (mark) が付け加えられる。
  5. `t' は、スレッドの際に段付けする位置を意味する。

例を以下に示します。

     (setq mew-summary-form
           '(type (5 date) " " (-4 size) " " (14 from) " " t (30 subj) "|" (0 body)))

`mew-summary-form-from-me-prefix' は、自分から送信されたメッセージの宛
先の先頭に加えられる文字列です。初期値は "To:" です。

`mew-summary-form-extract-rule' は、From: フィールドからどの部分を切り
出すか指定するためのリストです。要素
は、'name、'comment、'address、'nickname、あるいは正規表現である必要が
あります。初期値は '(nickname) です。


次の例を考えて下さい。

     A: Kazu Yamamoto <kazu@example.org>
     B: kazu@example.org (Kazu Yamamoto)
     C: Kazuhiko Yamamoto (Kazu) <kazu@example.org>

それぞの要素は、以下のような意味を持ちます。

  1. 'name:: 名前の部分
          A. Kazu Yamamoto
          B. (No match)
          C. Kazuhiko Yamamoto (Kazu)
  2. 'comment:: コメントの部分
          A: (No match)
          B: Kazu Yamamoto
          C: (Kazu)
  3. 'address:: アドレスの部分
          A: kazu@example.org
          B: kazu@example.org
          C: kazu@example.org
  4. 'nickname:: `mew-addrbook-for-summary' の値に応じたアドレス帳の個
     人情報のある要素。`mew-addrbook-for-summary' の初期値は
     `'nickname' なので、通常はニックネームに変換される。何が指定できる
     かは、*Note draft-mode:: を参照のこと。
  5. (regex):: 最初に合致した文字列

ある要素が合致しない場合、次の要素が評価されます。どの要素も From: フィー
ルドに合致しない場合か、この値が `nil' の場合、From: フィールド全体が利
用されます。


`mew-summary-form-mark-delete' が `t' の場合、重複しているメッセージに
自動的に `D' マークが付きます。初期値は `nil' です。


`mew-summary-form-mark-spam' が `t' の場合、本文の一部に対する MD5 チェッ
クサムが一致しているメッセージに自動的に `D' マークが付きます。初期値は
`nil' です。

`mew-summary-form-mark-review' が `t' の場合、自分宛てのメッセージに自
動的に `*' マークが付きます。初期値は `nil' です。


いつも Emacs のフレーム全体で Mew を使いたい人は、以下の設定をして下さ
い。

     (setq mew-use-full-window t)


Summary モードの `SPC' は、`mew-summary-show-direction' によって、次の
メッセージの表示の仕方が変わります。また同様に、強いマークを付けた後カー
ソルが動く方向は `mew-summary-mark-direction' により指定できます。以下
の値を設定できます。

`up'
     上のメッセージを表示する。
`down'
     下のメッセージを表示する。
`next'
     読み進めている方向の次のメッセージを表示する。
`stop'
     次は表示しない。

両方とも初期値は `next' です。いつもメッセージを下から読む人は、以下の
ようにすればよいでしょう。

     (setq mew-summary-show-direction 'up)



File: mew.jis.info, Node: message-mode, Next: draft-mode, Prev: summary-mode, Up: Customize

Message mode
============

Emacs がサポートしてないデータ型のファイルは、Message バッファに直接表
示できません。そのデータをテキストに整形する外部コマンドをインストール
すれば、Message バッファに表示可能になります。

"w3m" と "emacs-w3m" をインストールすると、Text/Html を Message バッ
ファに表示できるようになります。(以下で説明する "wvHtml"、"xlhtml"、
"ppthtml" は、単なる "w3m" ではなく、国際化された "w3m-m17n" が必要で
す。) 両者をインストールしたら、"~/.mew.el" に以下の設定を加えて下さい。

     (condition-case nil
         (require 'mew-w3m)
       (file-error nil))

これで、あたかも Text/Plain であるかのように、Text/Html を Message バッ
ファに表示できるようになります。この際も、以下で説明する `C-cC-e' の操
作は有効です。

"wvHtml"、"xlhtml"、"ppthtml" というコマンドをインストールすれば、それ
ぞれ WORD、Excel、PowerPoint ファイルのテキスト部分を、Message バッファ
に表示可能です。これらのコマンドは、HTML を利用するので、上記の
Text/Html の設定を完了させて下さい。また、UTF-8 (Unicode) を利用します
ので、Emacs 21.4 には、Mule-UCS もインストールして下さい。これで、たと
えば WORD ファイルをあたかもテキストのように、Message バッファに表示可
能になります。

外部のプログラムの整形結果を Message バッファに表示する代わりに、外部の
プログラム自身にそのデータを表示させることもできます。これには
`C-cC-e' を使います。

Message バッファに画像を表示することもできます。また `C-cC-e' を使い、
外部のプログラムに表示させることも可能です。

HTML は `C-cC-e' を使って外部のブラウザに表示できます。Windows やMac で
はデフォルトのブラウザが利用されます。Unix では、以下のように"mozilla"
が初期値となっています。

     (defvar mew-prog-text/html-ext '("mozilla" ("-remote" "openFile(%s)") t))

たとえば、これを "firefox" に変更するには以下のようにします。

     (setq mew-prog-text/html-ext
           '("firefox" ("-a" "firefox" "-remote" "openFile(%s)") t))

Office 関連のファイルも、`C-cC-e' を使えば、それぞれのアプリケーション
で表示可能です。Windows や Mac では、文字通り Office のアプリケーション
が起動されます。Unix では、以下のように "ooffice" が初期値となっていま
す。

     (defvar mew-prog-msword-ext "ooffice")
     (defvar mew-prog-msexcel-ext "ooffice")
     (defvar mew-prog-mspowerpoint-ext "ooffice")

これを "soffice" に変更するには以下のようにします。

     (setq mew-prog-msword-ext "soffice")
     (setq mew-prog-msexcel-ext "soffice")
     (setq mew-prog-mspowerpoint-ext "soffice")

また Office 関連のアプリケーションに対し、`SPC' などでは内容を表示せず、
`C-cC-e' では "wvHtml" などを使って Message バッファに表示するには、以
下のように設定します。

     (setq mew-prog-msword  '(nil mew-mime-application/msword))
     (setq mew-prog-msexcel '(nil mew-mime-application/msexcel))
     (setq mew-prog-mspowerpoint '(nil mew-mime-application/mspowerpoint))

あらかじめ定められているコマンドではなく、任意の外部コマンドを呼び出し
たい場合は、`C-uC-cC-e' と入力して下さい。

最近、Multipart/Alternative の中に Text/Plain と Text/Html の両方が入っ
ており、どちらかを選ぶようになっているメッセージを多く見掛けます。Mew
は、標準では Text/Plain の方を優先して表示します。"emacs-w3m" をインス
トールすれば、Text/Html の方を優先したくなるかもしれません。その場合、
以下の設定を "~/.mew.el" に加えて下さい。(ここで *Note multipart:: を読
み、`:' の使い方も思い出しておきましょう。)

     (setq mew-mime-multipart-alternative-list
           '("Text/Html" "Text/Plain" ".*"))



